"""
@author: Gabriele Girelli
@contact: gigi.ga90@gmail.com
"""

import argparse
from oligo_melting.asserts import enable_rich_assert
from oligo_melting.const import DENATURANT_MODES
from oligo_melting.entab import NN_TABLES
from oligo_melting.melt import Melter
from oligo_melting.sequence import Sequence
from oligo_melting.scripts import arguments as ap
from ggc.args import check_threads  # type: ignore
from joblib import delayed, Parallel  # type: ignore
import logging
import os
import pandas as pd  # type: ignore
from tqdm import tqdm  # type: ignore


def init_parser(subparsers: argparse._SubParsersAction) -> argparse.ArgumentParser:
    parser = subparsers.add_parser(
        "secstr",
        description="""
Corrects melting temperature of a secondary structure, predicted with
OligoArrayAux, based on denaturant (formamide) concentration. References:
 [1] McConaughy et al, Biochemistry(8), 1969;
 [2] Wright et al, Appl. env. microbiol.(80), 2014.
""",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help="Calculate melting temperature of secondary structures.",
    )

    parser.add_argument(
        "input",
        type=str,
        help="""
        Tab-separated file with dG, dH, and Tm columns (e.g., generated by a
        software like OligoArrayAux). Tm is expected to be in Celsius degree, while
        dH and dG in kcal / mol.""",
    )
    parser.add_argument(
        "-T",
        type=str,
        help="""Duplex type. Possible values: DNA:DNA (based on ref.3, default),
        RNA:RNA (based on ref.1), DNA:RNA (based on ref.2., given DNA sequence)
        or RNA:DNA (based on ref.2, given RNA sequence). The first nucleic acid type
        indicates the provided sequence.""",
        choices=NN_TABLES.keys(),
        default=Melter.DEFAULT_NN,
    )

    output = parser.add_argument_group("output arguments")
    output.add_argument(
        "-O", metavar="output", type=str, help="""Path to output file."""
    )
    output.add_argument(
        "--curve-range",
        type=float,
        metavar="range",
        help=f"""Range size to scan around the melting temperature, to build the
        melting curve. Default: {Melter.DEFAULT_RANGE}""",
        default=Melter.DEFAULT_RANGE,
    )
    output.add_argument(
        "--curve-step",
        type=float,
        metavar="range",
        help=f"""Temperature step used to scan the specified range, when building
        the melting curve. Default: {Melter.DEFAULT_STEP}""",
        default=Melter.DEFAULT_STEP,
    )

    chemistry = parser.add_argument_group("chemistry-related arguments")
    chemistry.add_argument(
        "-f",
        type=float,
        metavar="fa_conc",
        help="""Formamide concentration in %%(v,v).""",
        default=0,
    )
    chemistry.add_argument(
        "--out-curve",
        type=str,
        metavar="output",
        help="""Provide path to file where melting curve points should be
        stored.""",
    )

    advanced = parser.add_argument_group("advanced arguments")
    advanced.add_argument(
        "-t",
        type=int,
        metavar="threads",
        help="""Number of threads for parallelization. Default: 1""",
        default=1,
    )

    parser = ap.add_version_option(parser)
    parser.set_defaults(parse=parse_arguments, run=run)

    return parser


@enable_rich_assert
def parse_arguments(args: argparse.Namespace) -> argparse.Namespace:
    assert os.path.exists(args.input), "file not found: %s" % args.input
    assert args.f >= 0, "concentration cannot be negative."
    assert args.curve_range > 0, "temperature range must be positive."
    assert args.curve_step > 0, "temperature step must be positive."
    args.t = check_threads(args.t)
    return args


def melt_correct(row, melter):
    row["Tm"] = melter.denaturant.mcconaughy_correction(row["Tm"])
    return row


def run_melting(args, melter):
    data = pd.read_csv(args.input, "\t")

    colList = ["Tm"]
    assert all([x in data.columns for x in colList])
    if args.t == 1:
        for ri in tqdm(data.index):
            data.loc[ri, "Tm"] = melter.denaturant.mcconaughy_correction(
                data.loc[ri, "Tm"]
            )
    else:
        data = Parallel(n_jobs=args.t, verbose=11)(
            delayed(melt_correct)(row[1], melter) for row in data.iterrows()
        )
        data = pd.concat(data, axis=1).transpose()
    return data


def export_curve(args, data, melter):
    curveData = []
    for ri in tqdm(data.index):
        tm = data.loc[ri, "Tm"]
        h = data.loc[ri, "dH"] if "dH" in data.columns else None
        s = data.loc[ri, "dS"] if "dS" in data.columns else None
        name = data.loc[ri, "name"] if "name" in data.columns else "mer_%d" % ri
        seq = Sequence("", args.T.split(":")[0], name)
        curve = pd.DataFrame(melter.melting_curve(seq, h, s, tm, correctIons=False))
        curve["name"] = name
        curveData.append(curve)
    curveData_df = pd.concat(curveData)
    curveData_df.columns = ["t", "fraction", "name"]
    curveData_df.to_csv(args.out_curve, "\t", index=False)


def print_data(data):
    print("\t".join(data.columns))
    for row in data.iterrows():
        print("\t".join(row[1].astype("str").tolist()))


@enable_rich_assert
def run(args: argparse.Namespace) -> None:
    melter = Melter()
    melter.denaturant.conc = args.f
    melter.load_nn_table(args.T)
    melter.curve_range = args.curve_range
    melter.curve_step = args.curve_step
    melter.denaturant.mode = DENATURANT_MODES.MCCONAUGHY

    data = run_melting(args, melter)

    if args.out_curve is not None:
        export_curve(args, data, melter)

    print_data(data)

    if args.O is not None:
        with open(args.O, "w+") as OH:
            data.to_csv(OH, "\t", index=False, float_format="%.3f")

    logging.info("That's all! :smiley:")
